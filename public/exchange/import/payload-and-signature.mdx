import Zoom from 'react-medium-image-zoom'
import 'react-medium-image-zoom/dist/styles.css'

Here is a little diagram to explain how the `payload` and the `signature` are generated:

<Zoom>
    <img
      alt="Payload and Payload Signature generation diagram"
      src="/exchange/payload-signature-generation.png"
    />
</Zoom>

- `payload`: the trade parameters are assembled in a [protobuf](https://developers.google.com/protocol-buffers) message. Then using the protobuf tools we do a [binary encoding](https://developers.google.com/protocol-buffers/docs/encoding) of the protobuf (Byte Array). Finally, with [base64Url encoding](https://en.wikipedia.org/wiki/Base64) we get the `payload` field.
- `signature`: From the binary encoding of the previous [protobuf](https://developers.google.com/protocol-buffers) (Byte Array), we sign it with [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) and the provider's private key to get a Signature Byte Array. Finally, with [base64Url encoding](https://en.wikipedia.org/wiki/Base64) we get the `signature` field ([more details](#jws-signature)).


### Input field: nonce

A nonce field will be passed as a parameter of the **/swap** endpoint.  
It is a 32 bytes nonce which is generated by the hardware wallet to avoid replay attacks.  
It will be base 64 URL encoded before being sent to the **/swap** endpoint.

### Output field: providerSig

The real return value of the **/swap** endpoint is the `providerSig` field with the JSON Web Signature (JWS) in compact form within:
- `providerSig.payload` - base64 URL of the binary serialized protobuf message.NewTransactionResponse.
- `providerSig.signature` - base64 URL of the ES256 signature of providerSig.payload. More details in the [JWS signature](#jws-signature) section.

### Signature usage
- Payload and Signature  
From the provider to Ledger Live. The payload is a protobuf message containing the trade data. It is generated by the provider and sent to Ledger Live.
```go copy
type Payload struct {
  payin_address,      // address (of provider)
  refund_address,     // address (of customer)
  payout_address,     // address (of customer)
  currency_from,      // currency name (to provider)
  currency_to,
  amount_to_provider, // amount (to provider)
  amount_to_wallet,   // amount (to customer)
  device_transaction_id,
  device_transaction_id_ng,
  â€¦
}
R, S := Sign(payload, privKey)
```

- Validate  
Exchange app checks and validates the payload (signature and content).
```go copy
// Compare nonce in payload
Verify((R, S), payload, pubKey)
```

- Display  
Exchange app requests approval to the user by displaying the operation summary on screen. 
```c copy
Validate?
Send currency_from amount_to_provider
Receive currency_to amount_to_wallet
```

### JWS-Signature
The output field is `providerSig`, and is based on the [flattened JWS JSON](https://www.rfc-editor.org/rfc/rfc7515#section-7.2.2), without the optional `protected` and `header` parameters.

The algorithms supported by Ledger are [ES256](https://www.rfc-editor.org/rfc/rfc7518#section-3.4) with secp256k1 or secp256r1 curve. There is no need to specify them into the `header`,
as we will store your public key with this information in our system.

As specified in the JWA spec, the signature is a concatenation of the (R, S) pair in a 64 octets array, and not the ASN1 format.

The [JWS RFC](https://www.rfc-editor.org/rfc/rfc7515#section-5.1) requires the signature to be computed on: `<BASE64URL_HEADER>.<BASE64URL_PAYLOAD>`. As we don't require any `header`, the signature has to be computed on: `.<BASE64URL_PAYLOAD>`.