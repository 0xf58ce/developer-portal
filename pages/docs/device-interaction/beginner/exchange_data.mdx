import { Callout } from "nextra/components";

# Exchange data with the device

## Overview

This tutorial demonstrates how to send and receive data from a Ledger device using Application Protocol Data Units (APDUs). We'll explore both direct APDU handling and using pre-defined commands for ease of use.

## Prerequisites

Make sure you have a connected device session ID available from the previous connection tutorial.

## Sending an APDU

### Recommended Practices

<Callout> 
  Whenever possible, use [pre-defined commands](#sending-a-pre-defined-command) or [custom build commands](#building-a-new-command) rather than dealing with APDUs directly. This approach enhances code reusability and maintainability.
</Callout>

### Step 1: Building the APDU

To construct an APDU, use `ApduBuilder`. Here's an example for opening the Bitcoin app:

```ts
import { ApduBuilder } from "@ledgerhq/device-management-kit";

const openAppApduArgs = { cla: 0xe0, ins: 0xd8, p1: 0x00, p2: 0x00 };
const apdu = new ApduBuilder(openAppApduArgs)
  .addAsciiStringToData("Bitcoin")
  .build();
```
### Step 2: Sending the APDU

Send the constructed APDU using the `sdk.sendApdu` method:

```ts
const apduResponse = await sdk.sendApdu({ sessionId, apdu });
```
### Step 3: Parsing the Response

Parse the response using `ApduParser` and check for success:

```ts
import { ApduParser, CommandUtils } from "@ledgerhq/device-management-kit";

const parser = new ApduParser(apduResponse);

if (!CommandUtils.isSuccessResponse(apduResponse)) {
  throw new Error(
    `Unexpected status word: ${parser.encodeToHexaString(apduResponse.statusCode)}`,
  );
}
```

## Sending a Pre-defined Command

For convenience, pre-defined commands simplify APDU building and response parsing.

<Callout type="warning" emoji="⚠️">
  Most of the commands will reject with an error if the device is locked. Ensure that the device is unlocked before sending commands. You can check the device session state <code>(sdk.getDeviceSessionState)</code> to know if the device is locked.

  Most of the commands will reject with an error if the response status word is not <code>0x9000</code> (success response from the device).
</Callout>

### Open App

Opens the app with the given name: 

```ts
import { OpenAppCommand } from "@ledgerhq/device-management-kit";

const command = new OpenAppCommand("Bitcoin");
await sdk.sendCommand({ sessionId, command });
```

If the device is unlocked, it does not resolve/reject until the user has confirmed or denied the app opening on the device.

### Close App

Closes the currently open app:

```ts
import { CloseAppCommand } from "@ledgerhq/device-management-kit";

const command = new CloseAppCommand();
await sdk.sendCommand({ sessionId, command });
```

### Get OS Version

Fetches the OS version information:

```ts
import { GetOsVersionCommand } from "@ledgerhq/device-management-kit";

const command = new GetOsVersionCommand();
const { seVersion, mcuSephVersion, mcuBootloaderVersion } = await sdk.sendCommand({ sessionId, command });
```

<Callout>
  If you want this information you can simply get it from the device session state by observing it with `sdk.getDeviceSessionState({ sessionId })`.
</Callout>

### Get App and Version

Retrieves the current app name and version:

```ts
import { GetAppAndVersionCommand } from "@ledgerhq/device-management-kit";

const command = new GetAppAndVersionCommand();
const { name, version } = await sdk.sendCommand({ sessionId, command });
```
<Callout>
  If you want this information you can simply get it from the device session state by observing it with `sdk.getDeviceSessionState({ sessionId })`.
</Callout>

## Sending a Pre-defined flow - Device Actions

Device actions define a succession of commands to be sent to the device.

They are useful for actions that require user interaction, like opening an app,
or approving a transaction.

The result of a device action execution is an observable that will emit different states of the action execution. These states contain information about the current status of the action, some intermediate values like the user action required, and the final result.

### Open App Device Action

```ts
import {
  OpenAppDeviceAction,
  OpenAppDAState,
} from "@ledgerhq/device-management-kit";

const openAppDeviceAction = new OpenAppDeviceAction({ appName: "Bitcoin" });

const { observable, cancel } = await dmk.executeDeviceAction({
  sessionId,
  openAppDeviceAction,
});

observable.subscribe({
  next: (state: OpenAppDAState) => {
    switch (state.status) {
      case DeviceActionStatus.NotStarted:
        console.log("Action not started yet");
        break;
      case DeviceActionStatus.Pending:
        const {
          intermediateValue: { userActionRequired },
        } = state;
        switch (userActionRequired) {
          case UserActionRequiredType.None:
            console.log("No user action required");
            break;
          case UserActionRequiredType.ConfirmOpenApp:
            console.log(
              "The user should confirm the app opening on the device",
            );
            break;
          case UserActionRequiredType.UnlockDevice:
            console.log("The user should unlock the device");
            break;
          default:
            /**
             * you should make sure that you handle all the possible user action
             * required types by displaying them to the user.
             */
            throw new Exception("Unhandled user action required");
            break;
        }
        console.log("Action is pending");
        break;
      case DeviceActionStatus.Stopped:
        console.log("Action has been stopped");
        break;
      case DeviceActionStatus.Completed:
        const { output } = state;
        console.log("Action has been completed", output);
        break;
      case DeviceActionStatus.Error:
        const { error } = state;
        console.log("An error occurred during the action", error);
        break;
    }
  },
});
```

### Example in React

See the [sample app](https://github.com/LedgerHQ/device-sdk-ts/tree/develop/apps/sample) for comprehensive examples showcasing the Device Management Kit's usage in React applications.
