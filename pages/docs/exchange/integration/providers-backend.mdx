import Zoom from 'react-medium-image-zoom'
import 'react-medium-image-zoom/dist/styles.css'
import { Tabs } from 'nextra/components'
import { Callout } from 'nextra/components'
 
# Backend

## Endpoints needed for Swap / Sell / Buy / Fund

In order to communicate with Ledgerâ€™s backend, you have to give us the mapping of the endpoints we need.

Those endpoints can vary depending on the service (swap/sell/buy/fund). Check the following tab to get the list of the endpoints needed. 

<Callout type="info" emoji="ðŸ‘‰">
  If you already have some endpoints with similar functions but different names, let us know because we might be able to adapt.
</Callout>

<Tabs items={['Swap', 'Sell', 'Buy', 'Fund']}>
  <Tabs.Tab>
  There are 5 main endpoints needed for the swap:
      - To get the list of available currencies: [/currencies](https://exchange-integration-swap.redoc.ly/#operation/getCurrencies).
      - To get the list of tradable pairs: [/pairs](https://exchange-integration-swap.redoc.ly/#operation/getPairs).
      - To query a rate: [/quote](https://exchange-integration-swap.redoc.ly/#operation/postQuote).
      - To create a signed swap binary payload [/swap](https://exchange-integration-swap.redoc.ly/#operation/postSwap).
      - To query a swap status: [/status](https://exchange-integration-swap.redoc.ly/#operation/getStatus).
  
  <Callout type="info" emoji="ðŸ”—">
  You will find all the information regarding the SWAP endpoints here: https://exchange-integration-swap.redoc.ly/, as well as additional details on some endpoints below. 
  </Callout>


  ### GET /pairs
  This endpoint is not required if all permutations returned by [/currencies](https://exchange-integration-swap.redoc.ly/#operation/getCurrencies) are supported.

  **Fixed quote**: The quote price is guaranteed until execution (or until end of quote validity period).

  **Float quote**: The quote price is indicative only, real price is computed at execution time

  ### POST /quote

  All fees are expressed in output currency. For example, during a ETH to USDT on ethereum swap, the fees are expressed in USDT on ethereum.

  Some requirements about the **/quote** endpoint:
  - The quote must work without user auth. It can require a Ledger auth.
  - The quote must be valid long enough (at least a few minutes).

  ### POST /swap
  Your Protobuf message should have the following structure:

  ```go copy
  syntax = "proto3";
  package ledger_swap;

  message NewTransactionResponse {
      string    payin_address = 1;
      string    payin_extra_id = 2;
      string    refund_address = 3;
      string    refund_extra_id = 4;
      string    payout_address = 5;
      string    payout_extra_id = 6;
      string    currency_from = 7;
      string    currency_to = 8;
      bytes     amount_to_provider = 9;
      bytes     amount_to_wallet = 10;
      string    device_transaction_id = 11; // Legacy nonce, no need to give a value
      bytes     device_transaction_id_ng = 12; // nonce
  }
  ```

  Explanation of each fields:
  - `payin_address`: provider address to receive payment
  - `payin_extra_id`: eventual memo for the payment (stellar payment, for instance)
  - `refund_address`: client address to receive back the payment funds in case the provider is not able to execute the swap for some unpredictable reasons
  - `refund_extra_id`: eventual memo for the payment (stellar payment, for instance)
  - `payout_address`: client address to receive the money resulting from a successful swap
  - `payout_extra_id`: eventual memo for the payment (stellar payment, for instance)
  - `currency_from`: must be set to value of `payloadCurrencyFrom` from the [/swap API request](#post-swap)
  - `currency_to`: must be set to value of `payloadCurrencyTo` from the [/swap API request](#post-swap)
  - `amount_to_provider`: amount of `currency_from` that the provider expects to receive from client
  - `amount_to_wallet`: amount of `currency_to` that the provider agrees to send to the client in exchange from `amount_to_provider`. This amount must also include the network fees that the provider will pay to send the crypto to the user.
  - `device_transaction_id`: swap transaction nonce provided by client at initialization (must be set to value of `nonce` from the API request) - this is a legacy property, only used by historical parter
  - `device_transaction_id_ng`: swap transaction nonce provided by client at initialization (must be set to value of `nonce` from the API request)

  Amounts must be in the lowest unit of the coin, encoded into a 16 bytes array in big endian.

  - 1 **BTC** would be `0x5F5E100` (100000000 in hexadecimal). The smallest unit is a **satoshi** which is `10^-8` **BTC**.
  So multiply 1 **BTC** by `10^8` â†’ `0x5F5E100`. 
  And `0x5F5E100` encoded into a 16 bytes array in big endian is `[0x00, ... 0x00, 0x05, 0xF5, 0xE1, 0x00]`.
  - 2 **ETH** would be `0x1BC16D674EC80000` (or 2000000000000000000). The smallest unit is a **wei** which is `10^-18` **ETH**.
  So multiply 2 **ETH** by `10^18` â†’ `0x1BC16D674EC80000`.
  And `0x1BC16D674EC80000` encoded into a 16 bytes array in big endian is `[0x00, ... 0x00, 0x1B, 0xC1, 0x6D, 0x67, 0x4E, 0xC8, 0x00, 0x00]`.


  ### GET /status
  - Explanation of the different output `status`:
      - `FINISHED`: Trade has been completed successfully (user has received payout transaction).
      - `EXPIRED`: Payin transaction was not received in time, trade is cancelled. User will be refunded if payin transaction is received afterwards.
      - `ON_HOLD`: Trade has been put on hold (eg: for KYC reasons). User must contact support.
      - `PENDING`: Trade is in progress (provider is waiting to receive payin transaction, or user is waiting to receive payout transaction)
      - `REFUNDED`: Trade has been cancelled, refund transaction has been successfully received by user.
      - `UNKNOWN`: Trade is in unknown state. User must contact support.  
  </Tabs.Tab>
  <Tabs.Tab>
  There are 3 main endpoints needed for the sell:
      - To get the list of available fiat, country, payment, method and amount: [/capabilities](https://exchange-integration-sell.redoc.ly/#operation/getCapabilities).
      - To get the list of available crypto-currencies: [/crypto-currencies](https://exchange-integration-sell.redoc.ly/#operation/getCryptoCurrencies).
      - To get the fiat amount that the user should expect -after all fees are deducted - as a payment for the given crypto amount: [/quotes](https://exchange-integration-sell.redoc.ly/#operation/getQuote).
  
  <Callout type="info" emoji="ðŸ”—">
  You will find all the information regarding the SELL endpoints here: https://exchange-integration-sell.redoc.ly/.
  </Callout>
  
  </Tabs.Tab>
  <Tabs.Tab>
  There are 3 main endpoints needed for the buy:
      - To get the list of available fiat, country, payment, method and amount: [/capabilities](https://exchange-integration-buy.redoc.ly/#operation/getCapabilities).
      - To get the list of available crypto-currencies: [/crypto-currencies](https://exchange-integration-buy.redoc.ly/#operation/getCrypto-currencies).
      - To get the crypto amount that the user should expect -after all fees are deducted - as a payment for the given fiat amount: [/quotes](https://exchange-integration-buy.redoc.ly/#operation/getQuote).  
  
 
  <Callout type="info" emoji="ðŸ”—">
  You will find all the information regarding the BUY endpoints here: https://exchange-integration-buy.redoc.ly/.
  </Callout>

  ### POST /quote
  All fees are expressed in output currency. For example, during a ETH to USDT on ethereum swap, the fees are expressed in USDT on ethereum.

  Some requirements about the **/quote** endpoint:
  - The quote must work without user auth. It can require a Ledger auth.
  - The quote must be valid long enough (at least a few minutes).
  </Tabs.Tab>
  <Tabs.Tab>
  [TBD] Contact Ledger for more info. 
  </Tabs.Tab>
</Tabs>


[//]: # (Info needed to be exchange with the provider, but not out loud publicly)
[//]: # (**IP address checking** )
[//]: # (Additionally, we also need a way to know if a user will be able to perform a coin swap given his IP.)
[//]: # (Our back-end can adapt to how you decide to do this, but we recommend you use a dedicated endpoint. Our back-end will send the userâ€™s IP address to that endpoint, without logging it. In response, your endpoint should tell us if the trade is accepted or rejected.)



## Payload & Signature

<Callout type="info" emoji="ðŸ‘‰">
  Not needed for Buy.
</Callout>

Here is a little diagram to explain how the `payload` and the `signature` are generated:

<Zoom>
    <img
      alt="Payload and Payload Signature generation diagram"
      src="/payload-signature-generation.png"
    />
</Zoom>



- `payload`: the trade parameters are assembled in a [protobuf](https://developers.google.com/protocol-buffers) message. Then using the protobuf tools we do a [binary encoding](https://developers.google.com/protocol-buffers/docs/encoding) of the protobuf (Byte Array). Finally, with [base64Url encoding](https://en.wikipedia.org/wiki/Base64) we get the `payload` field.
- `signature`: From the binary encoding of the previous [protobuf](https://developers.google.com/protocol-buffers) (Byte Array), we sign it with [ES256](https://ldapwiki.com/wiki/Wiki.jsp?page=ES256) and the provider's private key to get a Signature Byte Array. Finally, with [base64Url encoding](https://en.wikipedia.org/wiki/Base64) we get the `signature` field ([more details](#jws-signature)).


### Input field: nonce

A nonce field will be passed as a parameter of the **/swap** endpoint.  
It is a 32 bytes nonce which is generated by the hardware wallet to avoid replay attacks.  
It will be base 64 URL encoded before being sent to the **/swap** endpoint.

### Output field: providerSig

The real return value of the **/swap** endpoint is the `providerSig` field with the JSON Web Signature (JWS) in compact form within:
- `providerSig.payload` - base64 URL of the binary serialized protobuf message.NewTransactionResponse.
- `providerSig.signature` - base64 URL of the ES256 signature of providerSig.payload. More details in the [JWS signature](#jws-signature) section.

### Signature usage
- Payload and Signature
From the provider to Ledger Live. The payload is a protobuf message containing the trade data. It is generated by the provider and sent to Ledger Live.
```go copy
type Payload struct {
  payin_address,      // address (of provider)
  refund_address,     // address (of customer)
  payout_address,     // address (of customer)
  currency_from,      // currency name (to provider)
  currency_to,
  amount_to_provider, // amount (to provider)
  amount_to_wallet,   // amount (to customer)
  device_transaction_id,
  device_transaction_id_ng,
  â€¦
}
R, S := Sign(payload, privKey)
```

- Validate 
Exchange app checks and validates payload (signature and content).
```go copy
// Compare nonce in payload
Verify((R, S), payload, pubKey)
```

- Display  
Exchange app request approval to user by displaying swap summary on screen. 
```c copy
Validate?
Send currency_from amount_to_provider
Receive currency_to amount_to_wallet
```

### JWS-Signature
The output field is `providerSig` is base on the [flattened JWS JSON](https://www.rfc-editor.org/rfc/rfc7515#section-7.2.2), without the optional `protected` and `header` parameter.

The algorithm supported by Ledger are [ES256](https://www.rfc-editor.org/rfc/rfc7518#section-3.4) with secp256k1 or secp256r1 curve. There is no need to specify them into the `header`,
as we will store your public key with this information in our system.

As specified in the JWA spec, the signature is a concatenation of the (R, S) pair in a 64 octets array, and not the ASN1 format.

The [JWS RFC](https://www.rfc-editor.org/rfc/rfc7515#section-5.1) requires that the signature is compute on: `<BASE64URL_HEADER>.<BASE64URL_PAYLOAD>`. As we don't require any `header`, the signature have to be compute on: `.<BASE64URL_PAYLOAD>`.

